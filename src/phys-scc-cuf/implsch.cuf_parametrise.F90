! (C) Copyright 1989- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!
MODULE IMPLSCH_CUF_PARAMETRISE_MOD
  CONTAINS
  ATTRIBUTES(GLOBAL) SUBROUTINE IMPLSCH_CUF_PARAMETRISE (KIJS, KIJL, FL1, WAVNUM, CGROUP, CIWA, CINV, XK2CG, STOKFAC, EMAXDPT,  &
  & INDEP, DEPTH, IOBND, IODP, AIRD, WDWAVE, CICOVER, WSWAVE, WSTAR, UFRIC, TAUW, TAUWDIR, Z0M, Z0B, CHRNCK, CITHICK,  &
  & NEMOUSTOKES, NEMOVSTOKES, NEMOSTRN, NPHIEPS, NTAUOC, NSWH, NMWP, NEMOTAUX, NEMOTAUY, NEMOWSWAVE, NEMOPHIF, WSEMEAN, WSFMEAN,  &
  & USTOKES, VSTOKES, STRNMS, TAUXD, TAUYD, TAUOCXD, TAUOCYD, TAUOC, PHIOCD, PHIEPS, PHIAW, MIJ, XLLWS, ENH, NCHNK)
    
    ! ----------------------------------------------------------------------
    
    !**** *IMPLSCH* - IMPLICIT SCHEME FOR TIME INTEGRATION OF SOURCE
    !****             FUNCTIONS.
    
    
    !*    PURPOSE.
    !     --------
    
    !       THE IMPLICIT SCHEME ENABLES THE USE OF A TIMESTEP WHICH IS
    !       LARGE COMPARED WITH THE CHARACTERISTIC DYNAMIC TIME SCALE.
    !       THE SCHEME IS REQUIRED FOR THE HIGH FREQUENCIES WHICH
    !       RAPIDLY ADJUST TO A QUASI-EQUILIBRIUM.
    
    !**   INTERFACE.
    !     ----------
    
    !       *CALL* *IMPLSCH (KIJS, KIJL, FL1,
    !    &                   WVPRPT,
    !    &                   WVENVI, FF_NOW,
    !    &                   INTFLDS, WAM2NEMO,
    !    &                   MIJ,  XLLWS)
    !      *KIJS*    - LOCAL INDEX OF FIRST GRIDPOINT
    !      *KIJL*    - LOCAL INDEX OF LAST GRIDPOINT
    !      *FL1*     - FREQUENCY SPECTRUM(INPUT AND OUTPUT).
    !      *WVPRPT*  - WAVE PROPERTIES FIELDS
    !      *WVENVI*  - WAVE ENVIRONMENT
    !      *FF_NOW*    FORCING FIELDS
    !      *INTFLDS*   INTEGRATED/DERIVED PARAMETERS
    !      *WAM2NEMO*  WAVE FIELDS PASSED TO NEMO
    !      *MIJ*       LAST FREQUENCY INDEX OF THE PROGNOSTIC RANGE.
    !      *XLLWS*     TOTAL WINDSEA MASK FROM INPUT SOURCE TERM
    
    
    !     METHOD.
    !     -------
    
    !       THE SPECTRUM AT TIME (TN+1) IS COMPUTED AS
    !       FN+1=FN+DELT*(SN+SN+1)/2., WHERE SN IS THE TOTAL SOURCE
    !       FUNCTION AT TIME TN, SN+1=SN+(DS/DF)*DF - ONLY THE DIAGONAL
    !       TERMS OF THE FUNCTIONAL MATRIX DS/DF ARE YOWPUTED, THE
    !       NONDIAGONAL TERMS ARE NEGLIGIBLE.
    !       THE ROUTINE IS CALLED AFTER PROPAGATION FOR TIME PERIOD
    !       BETWEEN TWO PROPAGATION CALLS - ARRAY FL1 CONTAINS THE
    !       SPECTRUM AND FL IS USED AS AN INTERMEDIATE STORAGE FOR THE
    !       DIAGONAL TERM OF THE FUNCTIONAL MATRIX.
    
    
    !     REFERENCE.
    !     ----------
    
    !       S. HASSELMANN AND K. HASSELMANN, "A GLOBAL WAVE MODEL",
    !       30/6/85 (UNPUBLISHED NOTE)
    
    ! ----------------------------------------------------------------------
    
    USE WNFLUXES_CUF_PARAMETRISE_MOD, ONLY: WNFLUXES_CUF_PARAMETRISE
    USE STOKESTRN_CUF_PARAMETRISE_MOD, ONLY: STOKESTRN_CUF_PARAMETRISE
    USE SNONLIN_CUF_PARAMETRISE_MOD, ONLY: SNONLIN_CUF_PARAMETRISE
    USE SINFLX_CUF_PARAMETRISE_MOD, ONLY: SINFLX_CUF_PARAMETRISE
    USE SETICE_CUF_PARAMETRISE_MOD, ONLY: SETICE_CUF_PARAMETRISE
    USE SDIWBK_CUF_PARAMETRISE_MOD, ONLY: SDIWBK_CUF_PARAMETRISE
    USE SDISSIP_CUF_PARAMETRISE_MOD, ONLY: SDISSIP_CUF_PARAMETRISE
    USE SDEPTHLIM_CUF_PARAMETRISE_MOD, ONLY: SDEPTHLIM_CUF_PARAMETRISE
    USE IMPHFTAIL_CUF_PARAMETRISE_MOD, ONLY: IMPHFTAIL_CUF_PARAMETRISE
    USE SBOTTOM_CUF_PARAMETRISE_MOD, ONLY: SBOTTOM_CUF_PARAMETRISE
    USE FKMEAN_CUF_PARAMETRISE_MOD, ONLY: FKMEAN_CUF_PARAMETRISE
    USE FEMEANWS_CUF_PARAMETRISE_MOD, ONLY: FEMEANWS_CUF_PARAMETRISE
    USE CIWABR_CUF_PARAMETRISE_MOD, ONLY: CIWABR_CUF_PARAMETRISE
    USE cudafor
    USE PARKIND_WAVE, ONLY: JWIM, JWRB, JWRU, JWRO
    USE YOWDRVTYPE, ONLY: ENVIRONMENT, FREQUENCY, FORCING_FIELDS, INTGT_PARAM_FIELDS, WAVE2OCEAN
    
    USE YOWCOUP, ONLY: LWFLUX_D, LWVFLX_SNL_D, LWNEMOCOU_D, LWNEMOCOUSTRN_D
    USE YOWCOUT, ONLY: LWFLUXOUT_D
    USE YOWFRED, ONLY: FR_D, TH_D, COFRM4_D, FLMAX_D
    USE YOWICE, ONLY: FLMIN, LCIWABR_D, LICERUN_D, LMASKICE_D
    USE YOWPARAM, ONLY: NANG_D, NFRE_D, LLUNSTR_D
    USE YOWPCONS, ONLY: WSEMEAN_MIN, ROWATERM1
    USE YOWSTAT, ONLY: IDELT_D, LBIWBK_D
    USE YOWWNDG, ONLY: ICODE_D, ICODE_CPL_D
    USE YOWINDN, ONLY: MLSTHG_D
    
    
    IMPLICIT NONE
    ! ----------------------------------------------------------------------
    
    
    INTEGER, PARAMETER :: NANG_LOKI_PARAM = 24
    INTEGER, PARAMETER :: NFRE_LOKI_PARAM = 36
    INTEGER(KIND=JWIM), VALUE, INTENT(IN) :: KIJS, KIJL
    REAL(KIND=JWRB), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NANG_LOKI_PARAM, NFRE_LOKI_PARAM, NCHNK) :: FL1
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NFRE_LOKI_PARAM, NCHNK) :: WAVNUM
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NFRE_LOKI_PARAM, NCHNK) :: CGROUP
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NFRE_LOKI_PARAM, NCHNK) :: CIWA
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NFRE_LOKI_PARAM, NCHNK) :: CINV
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NFRE_LOKI_PARAM, NCHNK) :: XK2CG
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NFRE_LOKI_PARAM, NCHNK) :: STOKFAC
    
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NCHNK) :: EMAXDPT
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NCHNK) :: DEPTH
    INTEGER(KIND=JWIM), INTENT(IN), DEVICE, DIMENSION(KIJL, NCHNK) :: INDEP
    INTEGER(KIND=JWIM), INTENT(IN), DEVICE, DIMENSION(KIJL, NCHNK) :: IODP
    INTEGER(KIND=JWIM), INTENT(IN), DEVICE, DIMENSION(KIJL, NCHNK) :: IOBND
    
    REAL(KIND=JWRB), INTENT(IN), DEVICE, DIMENSION(KIJL, NCHNK) :: WDWAVE, CICOVER, AIRD, WSTAR, CITHICK
    REAL(KIND=JWRB), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: UFRIC, TAUW, TAUWDIR, Z0M, Z0B, CHRNCK, WSWAVE
    REAL(KIND=JWRB), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: WSEMEAN, WSFMEAN, USTOKES, VSTOKES, STRNMS
    REAL(KIND=JWRB), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: TAUXD, TAUYD, TAUOCXD, TAUOCYD, TAUOC, PHIOCD
    REAL(KIND=JWRB), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: PHIEPS, PHIAW
    REAL(KIND=JWRO), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: NEMOUSTOKES, NEMOVSTOKES, NEMOSTRN
    REAL(KIND=JWRO), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: NPHIEPS, NTAUOC, NSWH, NMWP, NEMOTAUX
    REAL(KIND=JWRO), INTENT(INOUT), DEVICE, DIMENSION(KIJL, NCHNK) :: NEMOTAUY, NEMOWSWAVE, NEMOPHIF
    INTEGER(KIND=JWIM), INTENT(OUT), DEVICE, DIMENSION(KIJL, NCHNK) :: MIJ
    REAL(KIND=JWRB), INTENT(OUT), DEVICE, DIMENSION(KIJL, NANG_LOKI_PARAM, NFRE_LOKI_PARAM, NCHNK) :: XLLWS
    REAL(KIND=JWRB), INTENT(INOUT), DEVICE, DIMENSION(KIJL, MLSTHG_D, NCHNK) :: ENH
    
    
    INTEGER(KIND=JWIM) :: IJ, K, M
    
    REAL(KIND=JWRB) :: DELT, DELTM, XIMP, DELT5
    REAL(KIND=JWRB) :: GTEMP1, GTEMP2, FLHAB
    REAL(KIND=JWRB), DEVICE :: RAORW
    REAL(KIND=JWRB), DEVICE :: EMEAN, FMEAN, HALP
    REAL(KIND=JWRB), DEVICE :: EMEANWS, FMEANWS
    REAL(KIND=JWRB) :: USFM
    REAL(KIND=JWRB), DEVICE :: F1MEAN, AKMEAN, XKMEAN
    REAL(KIND=JWRB), DEVICE :: PHIWA
    
    REAL(KIND=JWRB), DEVICE, DIMENSION(NANG_LOKI_PARAM) :: FLM
    REAL(KIND=JWRB), DEVICE, DIMENSION(NANG_LOKI_PARAM) :: COSWDIF, SINWDIF2
    REAL(KIND=JWRB), DEVICE, DIMENSION(NFRE_LOKI_PARAM) :: RHOWGDFTH
    !     *FLD* DIAGONAL MATRIX OF FUNCTIONAL DERIVATIVE
    !     *SL*  TOTAL SOURCE FUNCTION ARRAY.
    !     *SPOS* : POSITIVE SINPUT ONLY
    REAL(KIND=JWRB), DEVICE, DIMENSION(NANG_LOKI_PARAM, NFRE_LOKI_PARAM) :: FLD, SL, SPOS
    REAL(KIND=JWRB), DEVICE, DIMENSION(NANG_LOKI_PARAM, NFRE_LOKI_PARAM) :: CIREDUC
    REAL(KIND=JWRB), DEVICE, DIMENSION(NANG_LOKI_PARAM, NFRE_LOKI_PARAM) :: SSOURCE
    
    LOGICAL :: LCFLX
    INTEGER(KIND=JWIM) :: ICHNK
    INTEGER(KIND=JWIM), VALUE, INTENT(IN) :: NCHNK
    IJ = THREADIDX%X
    ICHNK = BLOCKIDX%Z
    
    IF (ICHNK <= NCHNK .and. IJ <= KIJL) THEN
      
      ! ----------------------------------------------------------------------
      
      
      
      !*    1. INITIALISATION.
      !        ---------------
      
      DELT = IDELT_D
      DELTM = 1.0_JWRB / DELT
      XIMP = 1.0_JWRB
      DELT5 = XIMP*DELT
      
      LCFLX = LWFLUX_D .or. LWFLUXOUT_D .or. LWNEMOCOU_D
      
      
      RAORW = MAX(AIRD(IJ, ICHNK), 1.0_JWRB)*ROWATERM1
      
      DO K=1,NANG_D
        COSWDIF(K) = COS(TH_D(K) - WDWAVE(IJ, ICHNK))
        SINWDIF2(K) = SIN(TH_D(K) - WDWAVE(IJ, ICHNK))**2
      END DO
      
      ! ----------------------------------------------------------------------
      
      !*    2. COMPUTATION OF IMPLICIT INTEGRATION.
      !        ------------------------------------
      
      !         INTEGRATION IS DONE FROM CDATE UNTIL CDTPRO FOR A BLOCK
      !         OF LATITUDES BETWEEN PROPAGATION CALLS.
      
      
      !     REDUCE WAVE ENERGY IF LARGER THAN DEPTH LIMITED WAVE HEIGHT
      IF (LBIWBK_D) THEN
        CALL SDEPTHLIM_CUF_PARAMETRISE(KIJS, KIJL, EMAXDPT(:, ICHNK), FL1(:, :, :, ICHNK), IJ)
      END IF
      
      !*    2.2 COMPUTE MEAN PARAMETERS.
      !        ------------------------
      
      CALL FKMEAN_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), WAVNUM(:, :, ICHNK), EMEAN, FMEAN, F1MEAN, AKMEAN, XKMEAN, IJ)
      
      DO K=1,NANG_D
        FLM(K) = FLMIN*MAX(0.0_JWRB, COSWDIF(K))**2
      END DO
      
      !     COMPUTE DAMPING COEFFICIENT DUE TO FRICTION ON BOTTOM OF THE SEA ICE.
      !!! testing sea ice attenuation (might need to restrict usage when needed)
      IF (LCIWABR_D) THEN
        CALL CIWABR_CUF_PARAMETRISE(KIJS, KIJL, CICOVER(:, ICHNK), FL1(:, :, :, ICHNK), WAVNUM(:, :, ICHNK),  &
        & CGROUP(:, :, ICHNK), CIREDUC, IJ)
        DO M=1,NFRE_D
          DO K=1,NANG_D
            CIREDUC(K, M) = CIWA(IJ, M, ICHNK)*CIREDUC(K, M)
          END DO
        END DO
      ELSE
        DO M=1,NFRE_D
          DO K=1,NANG_D
            CIREDUC(K, M) = CIWA(IJ, M, ICHNK)
          END DO
        END DO
      END IF
      
      ! ----------------------------------------------------------------------
      
      !*    2.3 COMPUTATION OF SOURCE FUNCTIONS.
      !         --------------------------------
      
      !*    2.3.1 ITERATIVELY UPDATE STRESS AND COMPUTE WIND INPUT TERMS.
      !           -------------------------------------------------------
      
      CALL SINFLX_CUF_PARAMETRISE(1, KIJS, KIJL, .true., FL1(:, :, :, ICHNK), WAVNUM(:, :, ICHNK), CINV(:, :, ICHNK),  &
      & XK2CG(:, :, ICHNK), WSWAVE(:, ICHNK), WDWAVE(:, ICHNK), AIRD(:, ICHNK), RAORW, WSTAR(:, ICHNK), CICOVER(:, ICHNK),  &
      & COSWDIF, SINWDIF2, FMEAN, HALP, FMEANWS, FLM, UFRIC(:, ICHNK), TAUW(:, ICHNK), TAUWDIR(:, ICHNK), Z0M(:, ICHNK),  &
      & Z0B(:, ICHNK), CHRNCK(:, ICHNK), PHIWA, FLD, SL, SPOS, MIJ(:, ICHNK), RHOWGDFTH, XLLWS(:, :, :, ICHNK), IJ)
      CALL SINFLX_CUF_PARAMETRISE(2, KIJS, KIJL, .true., FL1(:, :, :, ICHNK), WAVNUM(:, :, ICHNK), CINV(:, :, ICHNK),  &
      & XK2CG(:, :, ICHNK), WSWAVE(:, ICHNK), WDWAVE(:, ICHNK), AIRD(:, ICHNK), RAORW, WSTAR(:, ICHNK), CICOVER(:, ICHNK),  &
      & COSWDIF, SINWDIF2, FMEAN, HALP, FMEANWS, FLM, UFRIC(:, ICHNK), TAUW(:, ICHNK), TAUWDIR(:, ICHNK), Z0M(:, ICHNK),  &
      & Z0B(:, ICHNK), CHRNCK(:, ICHNK), PHIWA, FLD, SL, SPOS, MIJ(:, ICHNK), RHOWGDFTH, XLLWS(:, :, :, ICHNK), IJ)
      
      !     2.3.3 ADD THE OTHER SOURCE TERMS.
      !           ---------------------------
      
      CALL SDISSIP_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), FLD, SL, INDEP(:, ICHNK), WAVNUM(:, :, ICHNK),  &
      & XK2CG(:, :, ICHNK), EMEAN, F1MEAN, XKMEAN, UFRIC(:, ICHNK), COSWDIF, RAORW, IJ)
      
      !     Save source term contributions relevant for the calculation of ocean fluxes
      IF (LCFLX .and. .not.LWVFLX_SNL_D) THEN
        DO M=1,NFRE_D
          DO K=1,NANG_D
            SSOURCE(K, M) = SL(K, M)
          END DO
        END DO
      END IF
      
      CALL SNONLIN_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), FLD, SL, WAVNUM(:, :, ICHNK), DEPTH(:, ICHNK), AKMEAN,  &
      & ENH(:, :, ICHNK), IJ)
      
      IF (LCFLX .and. LWVFLX_SNL_D) THEN
        !     Save source term contributions relevant for the calculation of ocean fluxes
        !!!!!!  SL must only contain contributions contributed to fluxes into the oceans
        !       MODULATE SL BY IMPLICIT FACTOR
        DO M=1,NFRE_D
          DO K=1,NANG_D
            GTEMP1 = MAX((1.0_JWRB - DELT5*FLD(K, M)), 1.0_JWRB)
            SSOURCE(K, M) = SL(K, M) / GTEMP1
          END DO
        END DO
      END IF
      
      
      CALL SDIWBK_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), FLD, SL, DEPTH(:, ICHNK), EMAXDPT(:, ICHNK), EMEAN, F1MEAN, IJ &
      & )
      
      CALL SBOTTOM_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), FLD, SL, WAVNUM(:, :, ICHNK), DEPTH(:, ICHNK), IJ)
      
      ! ----------------------------------------------------------------------
      
      !*    2.4 COMPUTATION OF NEW SPECTRA.
      !         ---------------------------
      
      !     INCREASE OF SPECTRUM IN A TIME STEP IS LIMITED TO A FINITE
      !     FRACTION OF A TYPICAL F**(-4) EQUILIBRIUM SPECTRUM.
      
      USFM = UFRIC(IJ, ICHNK)*MAX(FMEANWS, FMEAN)
      
      IF (LLUNSTR_D) THEN
        DO K=1,NANG_D
          DO M=1,NFRE_D
            GTEMP1 = MAX((1.0_JWRB - DELT5*FLD(K, M)), 1.0_JWRB)
            GTEMP2 = DELT*SL(K, M) / GTEMP1
            FLHAB = ABS(GTEMP2)
            FLHAB = MIN(FLHAB, USFM*COFRM4_D(M)*DELT)
            FL1(IJ, K, M, ICHNK) = FL1(IJ, K, M, ICHNK) + IOBND(IJ, ICHNK)*SIGN(FLHAB, GTEMP2)
            FL1(IJ, K, M, ICHNK) = MAX(IODP(IJ, ICHNK)*CIREDUC(K, M)*FL1(IJ, K, M, ICHNK), FLM(K))
            SSOURCE(K, M) = SSOURCE(K, M) + DELTM*MIN(FLMAX_D(M) - FL1(IJ, K, M, ICHNK), 0.0_JWRB)
            FL1(IJ, K, M, ICHNK) = MIN(FL1(IJ, K, M, ICHNK), FLMAX_D(M))
          END DO
        END DO
      ELSE
        DO K=1,NANG_D
          DO M=1,NFRE_D
            GTEMP1 = MAX((1.0_JWRB - DELT5*FLD(K, M)), 1.0_JWRB)
            GTEMP2 = DELT*SL(K, M) / GTEMP1
            FLHAB = ABS(GTEMP2)
            FLHAB = MIN(FLHAB, USFM*COFRM4_D(M)*DELT)
            FL1(IJ, K, M, ICHNK) = FL1(IJ, K, M, ICHNK) + SIGN(FLHAB, GTEMP2)
            FL1(IJ, K, M, ICHNK) = MAX(CIREDUC(K, M)*FL1(IJ, K, M, ICHNK), FLM(K))
            SSOURCE(K, M) = SSOURCE(K, M) + DELTM*MIN(FLMAX_D(M) - FL1(IJ, K, M, ICHNK), 0.0_JWRB)
            FL1(IJ, K, M, ICHNK) = MIN(FL1(IJ, K, M, ICHNK), FLMAX_D(M))
          END DO
        END DO
      END IF
      
      IF (LCFLX) THEN
        CALL WNFLUXES_CUF_PARAMETRISE(KIJS, KIJL, MIJ(:, ICHNK), RHOWGDFTH, CINV(:, :, ICHNK), SSOURCE, CICOVER(:, ICHNK),  &
        & PHIWA, EMEAN, F1MEAN, WSWAVE(:, ICHNK), WDWAVE(:, ICHNK), UFRIC(:, ICHNK), AIRD(:, ICHNK), NPHIEPS(:, ICHNK),  &
        & NTAUOC(:, ICHNK), NSWH(:, ICHNK), NMWP(:, ICHNK), NEMOTAUX(:, ICHNK), NEMOTAUY(:, ICHNK), NEMOWSWAVE(:, ICHNK),  &
        & NEMOPHIF(:, ICHNK), TAUXD(:, ICHNK), TAUYD(:, ICHNK), TAUOCXD(:, ICHNK), TAUOCYD(:, ICHNK), TAUOC(:, ICHNK),  &
        & PHIOCD(:, ICHNK), PHIEPS(:, ICHNK), PHIAW(:, ICHNK), .true., IJ)
      END IF
      ! ----------------------------------------------------------------------
      
      !*    2.5 REPLACE DIAGNOSTIC PART OF SPECTRA BY A F**(-5) TAIL.
      !         -----------------------------------------------------
      
      CALL FKMEAN_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), WAVNUM(:, :, ICHNK), EMEAN, FMEAN, F1MEAN, AKMEAN, XKMEAN, IJ)
      
      !     MEAN FREQUENCY CHARACTERISTIC FOR WIND SEA
      CALL FEMEANWS_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), XLLWS(:, :, :, ICHNK), FMEANWS, IJ, EMEANWS)
      
      CALL IMPHFTAIL_CUF_PARAMETRISE(KIJS, KIJL, MIJ(:, ICHNK), FLM, WAVNUM(:, :, ICHNK), XK2CG(:, :, ICHNK),  &
      & FL1(:, :, :, ICHNK), IJ)
      
      
      !     UPDATE WINDSEA VARIANCE AND MEAN FREQUENCY IF PASSED TO ATMOSPHERE
      !     ------------------------------------------------------------------
      IF (LWFLUX_D) THEN
        IF (EMEANWS < WSEMEAN_MIN) THEN
          WSEMEAN(IJ, ICHNK) = WSEMEAN_MIN
          WSFMEAN(IJ, ICHNK) = 2._JWRB*FR_D(NFRE_D)
        ELSE
          WSEMEAN(IJ, ICHNK) = EMEANWS
          WSFMEAN(IJ, ICHNK) = FMEANWS
        END IF
      END IF
      
      
      !*    2.6 SET FL1 ON ICE POINTS TO ZERO
      !         -----------------------------
      
      IF (LICERUN_D .and. LMASKICE_D) THEN
        CALL SETICE_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), CICOVER(:, ICHNK), COSWDIF, IJ)
      END IF
      
      
      !*    2.7 SURFACE STOKES DRIFT AND STRAIN IN SEA ICE
      !         ------------------------------------------
      
      CALL STOKESTRN_CUF_PARAMETRISE(KIJS, KIJL, FL1(:, :, :, ICHNK), WAVNUM(:, :, ICHNK), STOKFAC(:, :, ICHNK),  &
      & DEPTH(:, ICHNK), WSWAVE(:, ICHNK), WDWAVE(:, ICHNK), CICOVER(:, ICHNK), CITHICK(:, ICHNK), USTOKES(:, ICHNK),  &
      & VSTOKES(:, ICHNK), STRNMS(:, ICHNK), NEMOUSTOKES(:, ICHNK), NEMOVSTOKES(:, ICHNK), NEMOSTRN(:, ICHNK), IJ)
      
      ! ----------------------------------------------------------------------
      
      
    END IF
  END SUBROUTINE IMPLSCH_CUF_PARAMETRISE
END MODULE IMPLSCH_CUF_PARAMETRISE_MOD
